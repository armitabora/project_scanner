import requests
import ssl
import socket
import re
from bs4 import BeautifulSoup
import whois
from datetime import datetime
from urllib.parse import urlparse
import certifi
from requests.exceptions import RequestException, SSLError, Timeout


''' Timeout for requests'''
REQUEST_TIMEOUT = 15
USER_AGENT = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
HEADERS = {'User-Agent': USER_AGENT}

def clean_url(url):
    """Ensure the URL is properly formatted before making requests."""
    if not url:
        raise ValueError("URL cannot be empty.")
    url = url.strip()  
    url = url.replace("'", "").replace('"', "")  
    if not url.startswith(("http://", "https://")):
        url = "https://" + url  
    return url

# SSL/TLS Security

def check_ssl(url):
    """Check if the website uses SSL/TLS and validate the certificate."""
    try:
        hostname = urlparse(url).netloc
        context = ssl.create_default_context(cafile=certifi.where())
        with socket.create_connection((hostname, 443), timeout=REQUEST_TIMEOUT) as sock:
            with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                cert = ssock.getpeercert()
                if cert:
                    return "Secure (Valid SSL Certificate)✅"
                else:
                    return "Insecure (No SSL Certificate)❌"
    except Exception as e:
        return f"SSL Error⚠️: {str(e)}"

# Security Headers

def check_headers(url):
    """Follow redirects and validate headers."""
    try:
        response = requests.get(
            url, 
            headers=HEADERS, 
            timeout=REQUEST_TIMEOUT, 
            allow_redirects=True 
        )
        headers = response.headers
        
        missing = []
        required = [
            'Content-Security-Policy',
            'X-Frame-Options',
            'X-Content-Type-Options',
            'Strict-Transport-Security'
        ]
        
        for header in required:
            if header not in headers:
                missing.append(header)
        
        return missing if missing else "All Security Headers Present✅"
    except RequestException:
        return "Error Fetching Headers❌"

# SQL Injection

def check_sql_injection(url):
    """Test for SQL Injection vulnerabilities."""
    try:
        test_payloads = [
            "' OR '1'='1", 
            "' OR 'a'='a", 
            "' OR 1=1--", 
            "' OR 'a'='a'--",
            "' UNION SELECT null,null--",
            "' UNION SELECT 'a','b'--"
        ]
        for payload in test_payloads:
            test_url = f"{url}?id={payload}"
            response = requests.get(test_url, timeout=REQUEST_TIMEOUT)
            response_text = response.text.lower()

            '''Check for specific SQL error patterns'''
            sql_error_indicators = [
                "sql syntax", 
                "mysql error", 
                "syntax error", 
                "unexpected end of sql command",
                "sql query failed",
                "sql server",
                "database error"
            ]

            if any(indicator in response_text for indicator in sql_error_indicators):
                return "SQL Injection Detected!❌"
        return "Safe✅"
    except requests.exceptions.RequestException as e:
        return f"Connection Error⚠️: {str(e)}"

# Cross-Site Scripting (XSS)

def check_xss(url):
    """Test for Cross-Site Scripting (XSS) vulnerabilities."""
    try:
        test_payloads = [
            "<script>alert('XSS')</script>", 
            "'><script>alert('XSS')</script>", 
            '"><script>alert(String.fromCharCode(88,83,83))</script>', 
            "<img src=x onerror=alert('XSS')>",
            "<svg/onload=alert('XSS')>",
            "<body onload=alert('XSS')>"
        ]
        for payload in test_payloads:
            test_url = f"{url}?q={payload}"
            response = requests.get(test_url, timeout=REQUEST_TIMEOUT)
            if payload in response.text:
                return "XSS Vulnerability Detected!❌"
        return "Safe✅"
    except requests.exceptions.RequestException as e:
        return f"Connection Error⚠️: {str(e)}"
    
#OS Command Injection
def check_os_command_injection(url):
    """Test for OS Command Injection vulnerabilities with reduced false positives."""
    try:
        '''Testing payloads for command injection'''
        test_payloads = [
            "; ls",  
            "| dir",  
            "& cat /etc/passwd",  
            "`whoami`",  
        ]

        '''Indicators of command injection'''
        command_injection_indicators = [
            "command not found", 
            "permission denied",  
            "syntax error",  
            "unexpected token",  
            "sh:",  
            "bash:",  
            "error:",  
        ]

        # Unexpected output indicators
        unexpected_output_indicators = [
            "root:x:0:0:",  
            "bin:x:1:1:",  
            "usr:x:1000:1000:",  
            "etc/passwd", 
            "list of files",  
            "directory:",  
        ]

        for payload in test_payloads:
            test_url = f"{url}?cmd={payload}"
            response = requests.get(test_url, timeout=REQUEST_TIMEOUT)
            response_text = response.text.lower()

            # Checking for command injection indicators
            has_command_injection = any(
                indicator in response_text for indicator in command_injection_indicators
            )

            # Checking for unexpected output
            has_unexpected_output = any(
                output in response_text for output in unexpected_output_indicators
            )

            if has_command_injection and has_unexpected_output:
                return "OS Command Injection Detected!❌"

        # If no indicators are found, returning safe
        return "Safe✅"
    except requests.exceptions.RequestException as e:
        return f"Connection Error⚠️: {str(e)}"

#I-FRAME Injection 
def check_iframe_injection(url):
    """Check for IFRAME Injection vulnerabilities."""
    try:
        response = requests.get(url, timeout=REQUEST_TIMEOUT)
        soup = BeautifulSoup(response.text, "html.parser")
        iframes = soup.find_all("iframe")

        
        for iframe in iframes:
            src = iframe.get("src", "").lower()
            if "javascript:" in src or "data:" in src or "about:blank" in src:
                return "IFRAME Injection Detected!❌"
        return "Safe✅"
    except requests.exceptions.RequestException as e:
        return f"Connection Error⚠️: {str(e)}"

def check_csrf_token(url):
    """Check for the presence of CSRF tokens in forms."""
    try:
        response = requests.get(url, timeout=REQUEST_TIMEOUT)
        soup = BeautifulSoup(response.text, "html.parser")
        csrf_token = soup.find("input", {"name": ["csrf_token", "csrfmiddlewaretoken", "_csrf"]})
        set_cookie_header = response.headers.get("Set-Cookie", "")
        if "SameSite" in set_cookie_header or "csrf" in set_cookie_header.lower():
            return "Safe (Modern CSRF Protection)✅"
        return "CSRF Token Missing!❌" if not csrf_token else "Safe✅"
    except requests.exceptions.RequestException as e:
        return f"Connection Error⚠️: {str(e)}"

# Server Fingerprint (Upgraded)
def check_server_info(url):
    """Detect outdated server versions."""
    try:
        response = requests.head(url, headers=HEADERS, timeout=REQUEST_TIMEOUT)
        server = response.headers.get('Server', '')
        
        '''Checking for outdated versions'''
        outdated = {
            'nginx': ['1.19.0', '1.18.0'],  # Add more versions
            'Apache': ['2.2.0', '2.4.0']
        }
        
        for software, versions in outdated.items():
            if software.lower() in server.lower():
                for version in versions:
                    if version in server:
                        return f"Outdated {software} ({version})"
        
        return server if server else "Not Found"
    except RequestException:
        return "Error Fetching Server Info"


    
# Session Security (Enhanced)
def check_session_security(url):
    """Check for HttpOnly/Secure/SameSite flags."""
    try:
        response = requests.get(url, headers=HEADERS, timeout=REQUEST_TIMEOUT)
        cookies = response.headers.get('Set-Cookie', '')
        
        issues = []
        if 'HttpOnly' not in cookies:
            issues.append("Missing HttpOnly❌")
        if 'Secure' not in cookies and url.startswith('https'):
            issues.append("Missing Secure❌")
        if 'SameSite' not in cookies:
            issues.append("Missing SameSite❌")
        
        return "Session Security Issues Detected: " + ", ".join(issues) if issues else "Safe✅"
    except RequestException:
        return "Connection Error"

# Add these new functions to scanner.py

def check_authentication(url):
    """Check for common authentication vulnerabilities."""
    try:
        # Test for default credentials
        default_credentials = [
            ("admin", "admin"),
            ("admin", "password"),
            ("root", "root"),
            ("user", "user")
        ]
        
        login_urls = [
            f"{url}/login",
            f"{url}/admin",
            f"{url}/wp-login.php",
            f"{url}/administrator"
        ]
        
        for login_url in login_urls:
            try:
                response = requests.get(login_url, timeout=REQUEST_TIMEOUT)
                if response.status_code == 200 and any(x in response.text.lower() for x in ["login", "username", "password"]):
                    # Found a login page, test for default credentials
                    for username, password in default_credentials:
                        try:
                            auth_response = requests.post(
                                login_url,
                                data={"username": username, "password": password},
                                timeout=REQUEST_TIMEOUT,
                                allow_redirects=False
                            )
                            if auth_response.status_code == 302:  # Redirect on successful login
                                return f"Vulnerable: Default credentials ({username}/{password}) work❌"
                        except:
                            continue
                    return "Login page found (manual testing recommended)⚠️"
            except:
                continue
        
        # Check for authentication bypass
        auth_bypass_urls = [
            f"{url}/admin",
            f"{url}/wp-admin",
            f"{url}/administrator"
        ]
        
        for admin_url in auth_bypass_urls:
            try:
                response = requests.get(admin_url, timeout=REQUEST_TIMEOUT)
                if response.status_code == 200 and not any(x in response.text.lower() for x in ["login", "username", "password"]):
                    return "Possible authentication bypass (admin panel accessible without login)❌"
            except:
                continue
        
        return "No obvious authentication vulnerabilities found✅"
    except Exception as e:
        return f"Error checking authentication: {str(e)}⚠️"

def check_authorization(url):
    """Check for common authorization vulnerabilities."""
    try:
        # Test for IDOR (Insecure Direct Object Reference)
        test_urls = [
            f"{url}/user/1",
            f"{url}/profile/1",
            f"{url}/account/1"
        ]
        
        for test_url in test_urls:
            try:
                response = requests.get(test_url, timeout=REQUEST_TIMEOUT)
                if response.status_code == 200 and any(x in response.text.lower() for x in ["profile", "account", "user"]):
                    return "Possible IDOR vulnerability (direct object reference)⚠️"
            except:
                continue
        
        # Test for privilege escalation
        admin_urls = [
            f"{url}/admin",
            f"{url}/wp-admin",
            f"{url}/administrator"
        ]
        
        for admin_url in admin_urls:
            try:
                response = requests.get(admin_url, timeout=REQUEST_TIMEOUT)
                if response.status_code == 403:
                    # Try common privilege escalation tricks
                    modified_headers = HEADERS.copy()
                    modified_headers["X-Original-URL"] = admin_url
                    modified_headers["X-Rewrite-URL"] = admin_url
                    
                    bypass_response = requests.get(
                        f"{url}/random-page",
                        headers=modified_headers,
                        timeout=REQUEST_TIMEOUT
                    )
                    if bypass_response.status_code == 200:
                        return "Possible authorization bypass (header manipulation)❌"
            except:
                continue
        
        return "No obvious authorization vulnerabilities found✅"
    except Exception as e:
        return f"Error checking authorization: {str(e)}⚠️"


    
def get_hosting_info(url):
    """Fetch IP address, country, region, city, and organisation for a given URL."""
    try:
        domain = urlparse(url).netloc
        ip_address = socket.gethostbyname(domain)
        response = requests.get(f"http://ip-api.com/json/{ip_address}")
        data = response.json()
        if data["status"] == "success":
            return {
                "IP Address": ip_address,
                "Country": data.get("country", "Unknown"),
                "Region": data.get("regionName", "Unknown"),
                "City": data.get("city", "Unknown"),
                "Organisation": data.get("org", "Unknown")
            }
        else:
            return {
                "IP Address": ip_address,
                "Country": "Unknown",
                "Region": "Unknown",
                "City": "Unknown",
                "Organisation": "Unknown"
            }
    except Exception as e:
        return {
            "IP Address": "Unknown",
            "Country": "Unknown",
            "Region": "Unknown",
            "City": "Unknown",
            "Organisation": "Unknown"
        }

def get_domain_info(url):
    """Fetch domain creation date, expiration date, and age."""
    try:
        domain = urlparse(url).netloc
        domain_info = whois.whois(domain)
        creation_date = domain_info.creation_date
        expiration_date = domain_info.expiration_date

        if isinstance(creation_date, list):
            creation_date = creation_date[0]
        if isinstance(expiration_date, list):
            expiration_date = expiration_date[0]

        domain_age = (datetime.now() - creation_date).days // 365 if creation_date else "Unknown"

        return {
            "Domain Creation Date": creation_date.strftime("%Y-%m-%d") if creation_date else "Unknown",
            "Domain Expiration Date": expiration_date.strftime("%Y-%m-%d") if expiration_date else "Unknown",
            "Domain Age": f"{domain_age} years" if isinstance(domain_age, int) else "Unknown"
        }
    except Exception as e:
        return {
            "Domain Creation Date": "Unknown",
            "Domain Expiration Date": "Unknown",
            "Domain Age": "Unknown"
        }
    
def scan_website(url):
    """Run all security checks on a website."""
    try:
        url = clean_url(url)
        
        results = {
            "SSL/TLS Security": check_ssl(url),
            "Security Headers": check_headers(url),
            "SQL Injection": check_sql_injection(url),
            "XSS": check_xss(url),
            "OS Command Injection": check_os_command_injection(url),
            "IFRAME Injection": check_iframe_injection(url),
            "CSRF Protection": check_csrf_token(url),
            "Web Server Fingerprint": check_server_info(url),
            "Session Security": check_session_security(url),
            "Authentication Vulnerabilities": check_authentication(url),  # New
            "Authorization Vulnerabilities": check_authorization(url)     # New
        }

        '''Hosting and domain information'''
        results.update(get_hosting_info(url))
        results.update(get_domain_info(url))

        return results
    except Exception as e:
        return {"Error": f"An error occurred during scanning: {str(e)}"}


if __name__ == "__main__":
    url = input("Enter the URL to scan: ").strip()
    if not url:
        print("Error: No URL provided.")
    else:
        results = scan_website(url)
        for key, value in results.items():
            print(f"{key}: {value}")